<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<SimpleVisTool xmlns="weave.visualization.tools.*" 
			   xmlns:mx="http://www.adobe.com/2006/mxml"
			   xmlns:ui="weave.ui.*" 
			   layout="absolute" xmlns:userControls="weave.ui.userControls.*">
	<mx:Script>
		<![CDATA[
			import weave.api.WeaveAPI;
			import flash.utils.flash_proxy;
			
			import mx.events.FlexEvent;
			import mx.utils.ObjectUtil;
			
			import weave.Weave;
			import weave.core.SessionManager;
			import weave.api.core.ILinkableObject;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.FilteredColumn;
			import weave.api.data.IAttributeColumn;
			import weave.data.StatisticsCache;
			import weave.primitives.Bounds2D;
			import weave.primitives.LinkableBounds2D;
			import weave.ui.AttributeSelectorPanel;
			import weave.ui.ColumnListComponent;
			import weave.utils.BitmapText;
			import weave.utils.ColumnUtils;
			import weave.utils.DebugUtils;
			import weave.visualization.layers.AxisLayer;
			import weave.api.ui.IPlotLayer;
			import weave.visualization.layers.PlotLayer;
			import weave.visualization.plotters.AxisPlotter;
			import weave.visualization.plotters.DynamicPlotter;
			import weave.visualization.plotters.ParallelCoordinatesPlotter;
			import weave.visualization.plotters.SimpleAxisPlotter;
			
			public var _plotter:ParallelCoordinatesPlotter = null;
			override protected function constructor():void
			{
				super.constructor();
				
				// lock dynamic objects into place
				_plotter = initDefaultPlotter(ParallelCoordinatesPlotter) as ParallelCoordinatesPlotter;
				// add this callback first because it needs to be called for each column that is removed
				_plotter.columns.childListCallbacks.addImmediateCallback(this, handleColumnAddRemoveReorder);
				
				xAxisEnabled = true;
				visualization.includeNonSelectableLayersInAutoZoom.lock();
				visualization.enableZoomAndPan.value = false;
				_plotter.normalize.value = false;
				
				var objects:Array = [
						visualization.dataBounds,
						visualization.marginLeft,
						visualization.marginBottom,
						visualization.marginTop,
						visualization.marginRight,
						_plotter
					];
				for each (var object:ILinkableObject in objects)
					getCallbackCollection(object).addGroupedCallback(this, updateAxes, true);
				
				// BEGIN TEMPORARY SOLUTION
				
				// END TEMPORARY SOLUTION
				visualization.bottomMarginClickCallbacks.addImmediateCallback(this, handleXAxisClick);
				
				var count:int = getDefaultColumnsOfMostCommonKeyType().length;
				var columnsToInit:Array = [];
				for (var i:int = 0; i < count; i++)
					columnsToInit.push(_plotter.columns.requestObject(null, DynamicColumn, false));
				if (columnsToInit.length > 0)
					initColumnDefaults.apply(null, columnsToInit);
				
				_plotter.normalize.value=true;
				_plotter.alphaColumn.defaultValue.value=1;
				_plotter.shapeSize.value=0;
				_plotter.lineStyle.weight.defaultValue.value=1;
				_plotter.shapeBorderThickness.value=2;
				_plotter.shapeBorderColor.value=0x000000;
				toolTitle.addImmediateCallback(this, updateTitle);
			}
			
			private function handleXAxisClick():void
			{
				AttributeSelectorPanel.openDefaultSelector(_plotter.columns);
			}
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				xAxisLayer.axisPlotter.setLabelFunction( getColumnTitle );
				xAxisLayer.axisPlotter.axisLabelRelativeAngle.value = -45;
				xAxisLayer.axisPlotter.labelHorizontalAlign.value = BitmapText.HORIZONTAL_ALIGN_RIGHT;
				xAxisLayer.axisPlotter.labelVerticalAlign.value = BitmapText.VERTICAL_ALIGN_TOP;
				xAxisLayer.axisPlotter.labelDistanceIsVertical.value = false;
				
				visualization.marginBottom.value = 80;
				visualization.marginTop.value    = 10;
				visualization.marginLeft.value   = 80;
				visualization.marginRight.value  = 10;
				
				visualization.includeNonSelectableLayersInAutoZoom.value = false;

				linkBindableProperty(_plotter.normalize, resizeCheckBox, "selected");
				linkBindableProperty(_plotter.alphaColumn.defaultValue, 		alphaSlider,		"value");
				linkBindableProperty(_plotter.shapeSize,  					shapeSizeSlider, 	"value");
				linkBindableProperty(_plotter.lineStyle.weight.defaultValue, thickessButtons, 	"selectedValue");
				linkBindableProperty(_plotter.curveType, curvatureButtons, "selectedValue");
				linkBindableProperty(_plotter.shapeToDraw, shapeCombo, "selectedItem");
				linkBindableProperty(_plotter.shapeBorderThickness, shapeBorderSizeSlider, "value");
				linkBindableProperty(_plotter.shapeBorderColor, shapeBorderColorPicker, "selectedColor");
			}
			
			public function get colorColumn():DynamicColumn
			{
				var fc:FilteredColumn = Weave.root.getObject(Weave.DEFAULT_COLOR_DATA_COLUMN) as FilteredColumn;
				return fc.internalDynamicColumn;
			}
			
			private function getColumnTitle( index:Number ):String
			{
				try {
					var columns:Array = _plotter.columns.getObjects();
					return ColumnUtils.getTitle(columns[index]);
				} catch(e:Error) {}
				return "";
			}
			
			private var axisPrefix:String =  "Axis for: ";
			private function handleColumnAddRemoveReorder():void
			{
				var removedName:String = _plotter.columns.childListCallbacks.lastNameRemoved;
				if (removedName != null)
				{
					//trace("removed:",removedName)
					visualization.layers.removeObject(axisPrefix + removedName);
				}
			}
			
			private function updateAxes():void
			{
				// don't do anything if tool is not on the stage.
				if (!parent)
					return callLater(updateAxes);

				updateTitle();

				var columns:Array = _plotter.columns.getObjects();
				var axisPlotters:Array = getAxisPlotters();
				var axisLayers:Array = getAxisLayers();
				putAxesOnTopOfPlot();
				
				var dataBoundsYMin:Number = visualization.dataBounds.yMin.value;
				var dataBoundsYMax:Number = visualization.dataBounds.yMax.value;
				for (var i:int = 0; i < columns.length; i++)
				{
					var axisPlotter:AxisPlotter = axisPlotters[i] as AxisPlotter;
					
					if (_plotter.normalize.value)
					{
						axisPlotter.axisLineMinValue.value = WeaveAPI.StatisticsCache.getMin(columns[i]);
						axisPlotter.axisLineMaxValue.value = WeaveAPI.StatisticsCache.getMax(columns[i]);
					}
					else
					{
						axisPlotter.axisLineMinValue.value = dataBoundsYMin;
						axisPlotter.axisLineMaxValue.value = dataBoundsYMax;
					}
					axisPlotter.axisLineDataBounds.setBounds(i, dataBoundsYMin, i, dataBoundsYMax);
					axisPlotter.axisLabelRelativeAngle.value = 90;
					axisPlotter.tickCountRequested.value = 5;
					
					var title:String = ColumnUtils.getTitle(columns[i]);
					if( _plotter.normalize.value == false )
						title = "";
					axisPlotter.setSideAxisName(
						title, 0,
						0, visualization.marginBottom.value - 5,
						BitmapText.VERTICAL_ALIGN_BOTTOM,
						AxisPlotter.LABEL_POSITION_AT_AXIS_MIN,
						AxisPlotter.LABEL_CENTERED,
						Math.min(visualization.marginLeft.value*2, visualization.marginRight.value*2)
					);
					(axisLayers[i] as AxisLayer).visible = ((i == 0) || _plotter.normalize.value);
				}
				if (_plotter.normalize.value)
					xAxisLayer.visible = false;
				else
				{
					xAxisLayer.visible = true;
					xAxisLayer.axisPlotter.tickCountRequested.value = columns.length;
					xAxisLayer.axisPlotter.forceTickCount.value = true;
					xAxisLayer.axisPlotter.axisLabelRelativeAngle.value = -45;
					//						xAxisLayer.axisPlotter.axisLabelDistance.value = visualization.marginBottom.value - 5;
					xAxisLayer.axisPlotter.updateLabels();
				}
			}
			
			private function updateTitle():void
			{
				if (toolTitle.value == null)
				{
					// try to get unique attribute names separated by commas
					// should probably be unique names for parallel coordinates, single name for line chart with years listed...?
					var newTitle:String = "Parallel Coordinates of ";
					
					var uniqueColumns:Dictionary = new Dictionary();
					
					var columns:Array = _plotter.columns.getObjects(IAttributeColumn);
					for (var i:int = 0; i < columns.length; i++)
					{
						var column:IAttributeColumn = columns[i];
						newTitle += ColumnUtils.getTitle(column) + ", ";
					}
					title = newTitle.substr(0, newTitle.length-2);
				}
			}

			private function alphaSliderFormatFunction(value:Number):String {
				//return int(100 - (value * 100)) + "% Transparent";
				return int((value * 100)) + "% Opaque" + "\n" + int(100 - (value * 100)) + "% Transparent";
			}
			
			// add a new axis
			private function initAxis(name:String, labelVerticalAlign:String = BitmapText.VERTICAL_ALIGN_CENTER):void
			{
				var newAxisLayer:AxisLayer = visualization.layers.requestObject(name, AxisLayer, false);
				var newAxisPlotter:SimpleAxisPlotter = newAxisLayer.axisPlotter;
				visualization.linkToAxisProperties(newAxisLayer);
				newAxisPlotter.labelVerticalAlign.value = labelVerticalAlign;
			}
			// filter out the axesPlotter layers from the list of all the layers -- later these should be managed better?
			private function getAxisPlotters():Array
			{
				var axes:Array = getAxisLayers();
				for (var i:int = 0; i < axes.length; i++)
					axes[i] = (axes[i] as PlotLayer).getDynamicPlotter().internalObject;
				return axes;
			}
			private function getAxisLayers():Array
			{
				var axes:Array = getAxisNames();
				for (var i:int = 0; i < axes.length; i++)
					axes[i] = visualization.layers.getObject( axes[i] );
				return axes;
			}
			private function getAxisNames():Array
			{
				var axesNames:Array = _plotter.columns.getNames();
				for (var i:int = 0; i < axesNames.length; i++)
				{
					axesNames[i] = axisPrefix + axesNames[i];
					initAxis(axesNames[i]);
				}
				return axesNames;
			}
			private function putAxesOnTopOfPlot():void
			{
				var axisNames:Array = getAxisNames();
				axisNames.unshift( visualization.layers.getName( xAxisLayer ) );
				visualization.layers.setNameOrder(axisNames);
			}
		]]>
	</mx:Script>
	<mx:Number id="controlsFontSize">10</mx:Number>
	<ui:ControlPanel>
		<mx:Panel id="attributesPanel" 
				  label="Attributes for Line Chart" 
				  headerHeight="2"
				  borderColor="0x000000" 
				  backgroundColor="0xCCCCCC" 
				  backgroundAlpha="0.0" 
				  borderThickness="0.0" 
				  height="100%" 
				  width="100%" 
				  borderAlpha="0.2" 
				  borderStyle="none">
			<ui:DynamicColumnComponent label="Color" initialize="(event.target as DynamicColumnComponent).dynamicObject = colorColumn"/>
			<ui:ColumnListComponent label="Drag columns here" initialize="(event.target as ColumnListComponent).hashMap = _plotter.columns"/>
		</mx:Panel>
		<mx:Panel id="VizControlsPanel" 
				  label="Visualization Controls" 
				  headerHeight="2"
				  borderColor="0x000000" 
				  backgroundColor="0xCCCCCC" 
				  backgroundAlpha="0.0" 
				  borderThickness="0.0" 
				  height="100%" 
				  width="100%" 
				  borderAlpha="0.2" 
				  borderStyle="none"
				  >
			<mx:VBox width="100%" verticalGap="0">
				<mx:VBox width="100%" id="controls">
					<userControls:ControlsSubsetBox width="100%">
						<mx:Label text="Shape:" color="0x000000" fontSize="{controlsFontSize}" 
								  toolTip="This controls what shape is used to indicate the data points on the axes."/>
						<ui:CustomComboBox id="shapeCombo" dataProvider="{ParallelCoordinatesPlotter.shapesAvailable}"/>
						
						<mx:Label text="{shapeCombo.selectedItem == ParallelCoordinatesPlotter.NO_SHAPE ? 'Gap' : 'Shape'} size:" 
								  color="0x000000" fontSize="{controlsFontSize}" 
								  toolTip="This controls the size of the shapes indicating the data points on the axes."/>
						<mx:HSlider id="shapeSizeSlider" 
									width="100%" 
									snapInterval="1"
									tickInterval="1" 
									labels="['0', '1','','','','5','','','','','10','','','','','15','','','','','20']"
									minimum="0" maximum="20" 
									liveDragging="true"/>
						
					</userControls:ControlsSubsetBox>
					
					<userControls:ControlsSubsetBox width="100%" horizontalGap="2">
						<mx:HBox horizontalGap="0">
							<mx:Label text="Border color:" color="0x000000" fontSize="{controlsFontSize}"/>
							<mx:ColorPicker id="shapeBorderColorPicker"
											toolTip="This controls color of the border around the shape at each point."
											enabled="{!(shapeCombo.selectedItem == ParallelCoordinatesPlotter.NO_SHAPE || 
											shapeCombo.selectedItem == ParallelCoordinatesPlotter.EMPTY_CIRCLE ||
											shapeCombo.selectedItem == ParallelCoordinatesPlotter.EMPTY_SQUARE ||
											shapeBorderSizeSlider.value == 0) }"/>
						</mx:HBox>
						
						<mx:HBox width="100%" horizontalGap="0">
							<mx:Label text="Border thickness:" color="0x000000" fontSize="{controlsFontSize}" 
									  toolTip="This controls the border size of the shapes indicating the data points on the axes."/>
							<mx:HSlider id="shapeBorderSizeSlider" 
										width="100%" 
										snapInterval="1"
										tickInterval="1" 
										enabled="{shapeCombo.selectedItem != ParallelCoordinatesPlotter.NO_SHAPE}"
										labels="['0', '1', '2', '3', '4', '5']"
										minimum="0" maximum="5"
										liveDragging="true"/>
						</mx:HBox>
					</userControls:ControlsSubsetBox>
					
					<userControls:ControlsSubsetBox width="100%">
						<mx:Label text="Line Opacity:" 
								  color="0x000000" fontSize="{controlsFontSize}" 
								  toolTip="Use this control to see how transparent lines are.  Moving left increases transparency (decreased opacity), moving to the right decreases transparency (increased opacity) up to fully opaque (no transparency)."/>
						
						<mx:HSlider id="alphaSlider" 
									width="100%" 
									snapInterval="0.1"
									tickInterval="0.3" labels="{['10%', '40%', '70%', '100%']}" 
									dataTipFormatFunction="alphaSliderFormatFunction"
									minimum="0.1" maximum="1.0" 
									liveDragging="true"/>
					</userControls:ControlsSubsetBox>
					
					
					<userControls:ControlsSubsetBox width="100%">
						<mx:Label text="Line Curvature:" 
								  color="0x000000" fontSize="{controlsFontSize}" 
								  toolTip=""/>
						
						<mx:RadioButtonGroup id="curvatureButtons" />
						<mx:RadioButton label="Straight Line" value="ParallelCoordinatesPlotter.LINE_STRAIGHT" 		 	groupName="curvatureButtons"/>
						<!--<mx:RadioButton label="Away"          value="ParallelCoordinatesPlotter.LINE_CURVE_AWAY" 		groupName="curvatureButtons"/>
						<mx:RadioButton label="Towards"       value="ParallelCoordinatesPlotter.LINE_CURVE_TOWARDS" 	groupName="curvatureButtons"/>-->
						<mx:RadioButton label="Double"        value="ParallelCoordinatesPlotter.LINE_DOUBLE_CURVE"  	groupName="curvatureButtons"/>
					</userControls:ControlsSubsetBox>
					<userControls:ControlsSubsetBox width="100%">
						<mx:Label text="Line Thickness:" 
								  color="0x000000" fontSize="{controlsFontSize}" 
								  toolTip=""/>
						
						<mx:RadioButtonGroup id="thickessButtons" />
						<mx:RadioButton label="1" value="1"  groupName="thickessButtons"/>
						<mx:RadioButton label="2" value="2"  groupName="thickessButtons"/>
						<mx:RadioButton label="3" value="3"  groupName="thickessButtons"/>
						<mx:RadioButton label="4" value="4"  groupName="thickessButtons"/>
						
					</userControls:ControlsSubsetBox>
					<userControls:ControlsSubsetBox width="100%">
						<mx:CheckBox id="resizeCheckBox" label="Show an independent axis for each column." toolTip="Checked:&#13;&#x09;Each point along the line will between the minimum and maximum of a given column when it crosses it.  Each column is normalized to fit its data, so this is designed for independent columns (Parallel Coordinates).  &#13;&#13;Unchecked:&#13;&#x09;Only one axis is shown on the left and has the absolute minimum and maximum of all the columns used.  This is intended for columns that are equivalent or comparable, using the same data scales.  This is the typical functionality for a Line Chart. "/>
					</userControls:ControlsSubsetBox>
				</mx:VBox>
			</mx:VBox>
		</mx:Panel>
	</ui:ControlPanel>
</SimpleVisTool>
